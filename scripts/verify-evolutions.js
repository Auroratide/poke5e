import fs from "node:fs/promises"
import path from "node:path"

// Note: Almost this entire file was generated by Claude
// Very impressive it worked first try :S

/**
 * File structure of pokemon.json
 * Used for context on the file, since it's too big for the AI to handle
 * 
 * {
 * 	items: {
 *       id: string // e.g. "bulbasaur"
 * 		evolution: {
 * 			stage: number,
 * 			maxStage: number,
 * 			from: string[] // e.g. ["bulbasaur"]
 * 			to: {
 * 				id: string // e.g. "ivysaur"
 * 			}[]
 * 		},
 * 	}[]
 * }
 */

// Delay between API calls to respect rate limits
const API_DELAY = 50;

// Normalize Pokemon names/IDs for comparison
const normalizeId = (name) => {
	return name.toLowerCase()
		.replace(/[\s]/g, "-")
		.replace("â™€", "-f")
		.replace("â™‚", "-m")
		.replace(/[^a-z0-9\-]/g, "")
		.replace(/--+/g, "-")
		.replace(/^-|-$/g, "");
};

// Build evolution map from local Pokemon data
function buildLocalEvolutionMap(pokemonData) {
	const evolutionMap = new Map();
	
	for (const pokemon of pokemonData.items) {
		const evolutions = [];
		if (pokemon.evolution?.to) {
			for (const evolution of pokemon.evolution.to) {
				if (evolution.id) {
					evolutions.push(normalizeId(evolution.id));
				}
			}
		}
		evolutionMap.set(normalizeId(pokemon.id), evolutions);
	}
	
	return evolutionMap;
}

// Fetch evolution chain from PokeAPI
async function fetchEvolutionChain(pokemonId) {
	try {
		// First get the species data to find the evolution chain URL
		const speciesResponse = await fetch(`https://pokeapi.co/api/v2/pokemon-species/${pokemonId}`);
		if (!speciesResponse.ok) {
			throw new Error(`Species API returned ${speciesResponse.status}`);
		}
		
		const speciesData = await speciesResponse.json();
		const evolutionChainUrl = speciesData.evolution_chain.url;
		
		// Wait before next API call
		await new Promise(resolve => setTimeout(resolve, API_DELAY));
		
		// Fetch the evolution chain
		const chainResponse = await fetch(evolutionChainUrl);
		if (!chainResponse.ok) {
			throw new Error(`Evolution chain API returned ${chainResponse.status}`);
		}
		
		const chainData = await chainResponse.json();
		return chainData.chain;
		
	} catch (error) {
		throw new Error(`Failed to fetch evolution data: ${error.message}`);
	}
}

// Parse evolution chain from PokeAPI response
function parseEvolutionChain(chain) {
	const evolutionMap = new Map();
	
	function processChainNode(node) {
		const currentId = normalizeId(node.species.name);
		const evolutions = [];
		
		// Add all direct evolutions from this node
		for (const evolution of node.evolves_to) {
			evolutions.push(normalizeId(evolution.species.name));
			// Recursively process the evolution
			processChainNode(evolution);
		}
		
		evolutionMap.set(currentId, evolutions);
	}
	
	processChainNode(chain);
	return evolutionMap;
}

// Compare local and API evolution data
function compareEvolutions(localMap, apiMap, pokemonId) {
	const normalizedId = normalizeId(pokemonId);
	const localEvolutions = localMap.get(normalizedId) || [];
	const apiEvolutions = apiMap.get(normalizedId) || [];
	
	const missingEvolutions = [];
	
	for (const apiEvolution of apiEvolutions) {
		if (!localEvolutions.includes(apiEvolution)) {
			missingEvolutions.push(apiEvolution);
		}
	}
	
	return missingEvolutions;
}

async function main() {
	console.log("Starting Pokemon evolution audit...\n");
	
	try {
		// Load local Pokemon data
		const pokemonPath = path.join("static", "data", "pokemon.json");
		const pokemonData = JSON.parse(await fs.readFile(pokemonPath, { encoding: "utf-8" }));
		
		console.log(`Loaded ${pokemonData.items.length} Pokemon from local data`);
		
		// Build local evolution map
		const localEvolutionMap = buildLocalEvolutionMap(pokemonData);
		console.log("Built local evolution map\n");
		
		let processedCount = 0;
		let errorCount = 0;
		let missingEvolutionCount = 0;
		const errors = [];
		const missingEvolutions = [];
		
		// Process each Pokemon
		let startAt = 1
		let current = 1
		let shortcircuit = 0
		processedCount = current
		for (const pokemon of pokemonData.items) {
			// if (shortcircuit++ > 3) break
			if (current++ < startAt) continue

			processedCount++;
			const pokemonId = normalizeId(pokemon.id);
			
			try {
				console.log(`Processing ${processedCount}/${pokemonData.items.length}: ${pokemon.id}...`);
				
				// Fetch evolution chain from API
				const evolutionChain = await fetchEvolutionChain(pokemonId);
				const apiEvolutionMap = parseEvolutionChain(evolutionChain);
				
				// Compare evolutions
				const missing = compareEvolutions(localEvolutionMap, apiEvolutionMap, pokemon.id);
				
				if (missing.length > 0) {
					missingEvolutionCount += missing.length;
					for (const missingEvolution of missing) {
						const missingInfo = `${pokemon.id} should evolve into ${missingEvolution}`;
						missingEvolutions.push(missingInfo);
						console.log(`  âš ï¸  MISSING EVOLUTION: ${missingInfo}`);
					}
				}
				
				// Small delay between Pokemon to be respectful to the API
				await new Promise(resolve => setTimeout(resolve, API_DELAY));
				
			} catch (error) {
				errorCount++;
				const errorInfo = `${pokemon.id}: ${error.message}`;
				errors.push(errorInfo);
				console.log(`  âŒ ERROR: ${errorInfo}`);
			}
		}
		
		// Final report
		console.log("\n" + "=".repeat(60));
		console.log("EVOLUTION AUDIT COMPLETE");
		console.log("=".repeat(60));
		console.log(`Processed: ${processedCount} Pokemon`);
		console.log(`Errors: ${errorCount}`);
		console.log(`Missing evolutions found: ${missingEvolutionCount}`);
		
		if (errors.length > 0) {
			console.log("\nðŸ“‹ ERRORS SUMMARY:");
			for (const error of errors) {
				console.log(`  â€¢ ${error}`);
			}
		}
		
		if (missingEvolutions.length > 0) {
			console.log("\nðŸ“‹ MISSING EVOLUTIONS SUMMARY:");
			for (const missing of missingEvolutions) {
				console.log(`  â€¢ ${missing}`);
			}
		}
		
		if (errors.length === 0 && missingEvolutions.length === 0) {
			console.log("\nâœ… All evolution data appears to be complete!");
		}
		
	} catch (error) {
		console.error("Fatal error:", error.message);
		process.exit(1);
	}
}

main().catch(console.error);
