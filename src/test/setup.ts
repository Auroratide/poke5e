import { DataClass } from "$lib/DataClass"
import { expect, beforeEach } from "vitest"

beforeEach(() => {
	localStorage.clear()
})

// Generated by Claude
expect.extend({
	toEqualData(received: unknown, expected: unknown) {
		// Helper function to check if value is DataClass
		const isDataClass = (value: unknown): value is DataClass<unknown> => 
			value instanceof DataClass

		// Recursive function to transform values, replacing DataClass instances with their .data
		const transformValue = (value: unknown): unknown => {
			if (isDataClass(value)) {
				return value.data
			}

			if (Array.isArray(value)) {
				return value.map(transformValue)
			}

			if (value !== null && typeof value === "object") {
				const transformed: Record<string, unknown> = {}
				for (const [key, val] of Object.entries(value)) {
					transformed[key] = transformValue(val)
				}
				return transformed
			}

			return value
		}

		// Transform both values recursively
		const transformedReceived = transformValue(received)
		const transformedExpected = transformValue(expected)

		// Use vitest's built-in deep equality check on transformed values
		const pass = this.equals(transformedReceived, transformedExpected)

		if (!pass) {
			return {
				pass,
				message: () => {
					const diffString = this.utils.diff(transformedExpected, transformedReceived, {
						expand: this.expand,
					})
					return `expected data to be equal (DataClass instances compared by their .data property)\n\n${diffString ? diffString : `Expected: ${this.utils.printExpected(transformedExpected)}\nReceived: ${this.utils.printReceived(transformedReceived)}`}`
				},
			}
		}

		return {
			pass,
			message: () =>
				`expected data not to be equal (DataClass instances compared by their .data property)\nReceived: ${this.utils.printReceived(transformedReceived)}\nExpected: ${this.utils.printExpected(transformedExpected)}`,
		}
	},
})

